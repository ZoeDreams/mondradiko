# Copyright (c) 2020 the Mondradiko contributors.
# SPDX-License-Identifier: LGPL-3.0-or-later

LINKER_METHOD_TEMPLATES = '''
template <class ComponentType>
using BoundComponentMethod = wasm_trap_t* (ComponentType::*)(const wasm_val_t[], wasm_val_t[]);

template <class ComponentType, BoundComponentMethod<ComponentType> method>
static wasm_trap_t* componentMethodWrapper(const wasmtime_caller_t* caller, void* env, const wasm_val_t args[], wasm_val_t results[]) {
  World* world = reinterpret_cast<World*>(env);
  EntityId self_id = static_cast<EntityId>(args[0].of.i32);
  ComponentType& self = world->registry.get<ComponentType>(self_id);
  return (self.*method)(args, results);
}

static void finalizer(void*) { }

template <class ComponentType, BoundComponentMethod<ComponentType> method>
void linkComponentMethod(ScriptEnvironment* scripts, World* world, const char* symbol) {
  wasm_store_t* store = scripts->getStore();
  const wasm_functype_t* func_type = wasm_functype_new_0_0();
  wasmtime_func_callback_with_env_t callback = 
    componentMethodWrapper<ComponentType, method>;
  void* env = static_cast<void*>(world);

  wasm_func_t* func =
    wasmtime_func_new_with_env(store, func_type, callback, env, finalizer);

  scripts->addBinding(symbol, func);
}

'''

LINKER_LINK_FORMAT = "void {0}Component::linkScriptApi(ScriptEnvironment* scripts, World* world)"

LINKER_METHOD_WRAP = "linkComponentMethod<{0}, &{0}::{1}>(scripts, world, \"{0}_{1}\");"


class Linker:
    def __init__(self, output_file, component_name):
        self.output_file = open(output_file, "w")
        self.component_name = component_name
        self.methods = []

        f = self.output_file

        f.write("// Mondradiko scripting API linking implementation\n")
        f.write("// https://mondradiko.github.io/\n")
        f.write("// Generated by generate_binding.py\n\n")

        # Import the component we're linking
        component_include = "#include \"core/components/{0}Component.h\"\n\n"
        f.write(component_include.format(component_name))

        f.write("#include \"core/common/wasm_headers.h\"\n")
        f.write("#include \"core/world/World.h\"\n")
        f.write("#include \"core/scripting/ScriptEnvironment.h\"\n\n")
        f.write("namespace mondradiko {\n\n")
        f.write(LINKER_METHOD_TEMPLATES)

    def addMethod(self, method_name, method):
        # TODO(marceline-cramer) C++ name wrangling would go here
        # TODO(marceline-cramer) Also parsing overrides and automatic type conversions
        component_name = self.component_name + "Component"
        self.methods.append(LINKER_METHOD_WRAP.format(
            component_name, method_name))

    def finish(self):
        f = self.output_file

        # Implement Component::linkScriptApi()
        f.write(LINKER_LINK_FORMAT.format(self.component_name))
        f.write(" {\n")

        for method in self.methods:
            f.write("  ")  # Indent
            f.write(method)
            f.write("\n")

        # End of Component::linkScriptApi()
        f.write("}\n\n")

        # End of namespace
        f.write("} // namespace mondradiko\n\n")

        # Close linker source file
        f.close()


class CppBinding:
    def __init__(self, output_file, component_name):
        self.output_file = open(output_file, "w")
        self.component_name = component_name
        self.methods = []

        f = self.output_file

        f.write("// Mondradiko scripting API C++ bindings\n")
        f.write("// https://mondradiko.github.io/\n")
        f.write("// Generated by generate_binding.py\n\n")
        f.write("#pragma once\n\n")

        # Enter namespace
        f.write("namespace mondradiko {\n\n")

        # Class body
        f.write("class " + component_name + " {\n")

        # Public members
        f.write(" public:\n")

    def addMethod(self, method_name, method):
        f = self.output_file

        # Generate Doxygen-style tags
        docs = ""
        docs += cpp_documentation("brief", method["brief"])
        f.write(docs)

        if "return" not in method.keys():
            return_type = "void"
        else:
            return_type = method["return"]

        if "params" not in method.keys():
            parameters = []
        else:
            parameters = method["params"]

        parameter_list = ", ".join(parameters)

        # Define the method
        method_format = "  {} {}({});\n\n"
        f.write(method_format.format(return_type, method_name, parameter_list))

    def finish(self):
        pass

# Helper function to generate Doxygen tags


def cpp_documentation(tag, contents, indentation_level=2, margin=80):
    indent = " " * indentation_level

    docs = indent + "/**\n"

    # Format contents to avoid margin
    content_line_len = margin - indentation_level

    content_words = contents.split()
    word_count = len(content_words)
    # Pad words with empty string to avoid OOB
    content_words += ""

    content_header = indent + " *"
    content_line = content_header + " @" + tag
    for word_index in range(word_count):
        content_line += " " + content_words[word_index]

        if len(content_line) + len(content_words[word_index]) + 1 > content_line_len:
            docs += content_line + "\n"
            content_line = content_header
    if content_line != content_header:
        docs += content_line + "\n"

    docs += indent + " */\n"
    return docs


def print_usage(arg1):
    print("Usage:")
    print(" ", arg1, "[in_component_definition.toml]",
          "[linker.cc]", "[cpp_binding.h]")


def main():
    import sys
    import toml

    if len(sys.argv) != 4:
        print_usage(sys.argv[0])
        sys.exit(1)

    component_path = sys.argv[1]
    linker_path = sys.argv[2]
    cpp_binding_path = sys.argv[3]

    component = toml.load(component_path)

    # Open the files we'll be writing to
    component_name = component["name"]
    linker = Linker(linker_path, component_name)
    cpp_binding = CppBinding(cpp_binding_path, component_name)

    # Define methods
    methods = component["methods"]
    for method_name in methods.keys():
        method = methods[method_name]
        linker.addMethod(method_name, method)
        cpp_binding.addMethod(method_name, method)

    # Wrap up codegen
    linker.finish()
    cpp_binding.finish()


if __name__ == "__main__":
    main()
