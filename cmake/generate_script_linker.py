# Copyright (c) 2020 the Mondradiko contributors.
# SPDX-License-Identifier: LGPL-3.0-or-later

def print_usage(arg1):
  print("Usage:")
  print(" ", arg1, "[out_cpp_header.h]", "[in_component_definition.toml ... ]")

def main():
  import sys

  if len(sys.argv) < 3:
    print_usage(sys.argv[0])
    sys.exit(1)
  
  src_path = sys.argv[1]
  # component_paths = sys.argv[3:]

  src = open(src_path, "w")

  # This code is...
  # https://open.spotify.com/track/2VlK6rGP0GG2eOyLekcINe?si=GBLpP6l1T4iCM-yuZBeQVA

  src.write('''
// Mondradiko scripting API linking implementation
// https://mondradiko.github.io/
// Generated by generate_script_linker.py

#include "core/bindings/script_linker.h"

#include <iostream>

#include "core/common/wasm_headers.h"
#include "core/scripting/ScriptEnvironment.h"

namespace mondradiko {

namespace bindings {

// TODO(marceline-cramer) Get the components into this somehow
class TransformComponent {
 public:
  void update() {
    std::cout << "Calling TransformComponent::update()" << std::endl;
  }
};

template <class ComponentType>
using BoundComponentMethod = void (ComponentType::*)();

template <class ComponentType, BoundComponentMethod<ComponentType> method>
static wasm_trap_t* componentMethodWrapper(const wasmtime_caller_t* caller, void* env, const wasm_val_t args[], wasm_val_t results[]) {
  ScriptEnvironment* scripts = reinterpret_cast<ScriptEnvironment*>(env);
  (*scripts->getComponent<ComponentType>().*method)();
  return nullptr;
}

template <class ComponentType, BoundComponentMethod<ComponentType> method>
static void componentMethodFinalizer(void*) {}

template <class ComponentType, BoundComponentMethod<ComponentType> method>
bool linkComponentMethod(ScriptEnvironment* scripts, const char* symbol) {
  wasm_store_t* store = scripts->getStore();
  const wasm_functype_t* func_type = wasm_functype_new_0_0();
  wasmtime_func_callback_with_env_t callback = 
    componentMethodWrapper<ComponentType, method>;
  void* env = static_cast<void*>(scripts);
  void (*finalizer)(void*) = 
    static_cast<void (*)(void*)>(componentMethodFinalizer<ComponentType, method>);

  wasm_func_t* func =
    wasmtime_func_new_with_env(store, func_type, callback, env, finalizer);

  scripts->addBinding(symbol, func);

  return true;
}

bool linkScriptingApi(ScriptEnvironment* scripts) {
  ''')

  # Link all components' methods as defined in the configuration files
  src.write("  linkComponentMethod<TransformComponent, static_cast<BoundComponentMethod<TransformComponent>>(&TransformComponent::update)>(scripts, \"hello\");\n")

  # End of linkScriptingApi()
  src.write('''
  return true;
}

}  // namespace bindings
}  // namespace mondradiko

  ''')

  # TODO(marceline-cramer) Actually generate link definitions
  src.close()

if __name__ == "__main__":
  main()
