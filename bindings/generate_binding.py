# Copyright (c) 2020 the Mondradiko contributors.
# SPDX-License-Identifier: LGPL-3.0-or-later

def cpp_begin_header(header, component_name):
    header.write("// Mondradiko scripting API C++ bindings\n")
    header.write("// https://mondradiko.github.io/\n")
    header.write("// Generated by generate_binding.py\n\n")
    header.write("#pragma once\n\n")

    # Class body
    header.write("class " + component_name + " {\n")

    # Public members
    header.write(" public:\n")

def cpp_documentation(tag, contents, indentation_level=2, margin=80):
    indent = " " * indentation_level
    
    docs = indent + "/**\n"

    # Format contents to avoid margin
    content_line_len = margin - indentation_level

    content_words = contents.split()
    word_count = len(content_words)
    # Pad words with empty string to avoid OOB
    content_words += ""
 
    content_header = indent + " *"
    content_line = content_header + " @" + tag
    for word_index in range(word_count):
        content_line += " " + content_words[word_index]
        
        if len(content_line) + len(content_words[word_index]) + 1 > content_line_len:
            docs += content_line + "\n"
            content_line = content_header
    if content_line != content_header:
        docs += content_line + "\n"

    docs += indent + " */\n"
    return docs
    
def cpp_method(header, method_name, method, properties):
    # Generate Doxygen-style tags
    if properties:
        docs = ""
        docs += cpp_documentation("brief", properties["brief"])
        header.write(docs)
    
    if "return" not in method.keys():
        return_type = "void"
    else:
        return_type = method["return"]
    
    if "params" not in method.keys():
        parameters = []
    else:
        parameters = method["params"]

    parameter_list = ", ".join(parameters)
    
    # Define the method
    header.write("  {} {}({});\n\n".format(return_type, method_name, parameter_list))

def cpp_end_header(header):
    # End of class body
    header.write("};\n\n") 
    
def cpp_bindings(component, header_path):
    component_name = component["name"]

    with open(header_path, "w") as header:
        cpp_begin_header(header, component_name)
        
        # Define methods
        methods = component["methods"]
        for method_name in methods.keys():
            method = methods[method_name]
            
            if "properties" in method:
                method_properties = method["properties"]
            else:
                method_properties = method

            if "overloads" in method.keys():
                overloads = method["overloads"]
                for overload_name in overloads.keys():
                    overload = overloads[overload_name]
                    cpp_method(header, method_name, overload, method_properties)
            else:
                cpp_method(header, method_name, method, method_properties)

        cpp_end_header(header)

def print_usage(arg1):
    print("Usage:")
    print(" ", arg1, "[out_cpp_header.h]", "[in_component_definition.toml]")

def main():
    import sys
    import toml

    if len(sys.argv) != 3:
        print_usage(sys.argv[0])
        sys.exit(1)
    
    cpp_header_path = sys.argv[1]
    component_path = sys.argv[2]

    component = toml.load(component_path)
    cpp_bindings(component, cpp_header_path)

if __name__ == "__main__":
    main()
